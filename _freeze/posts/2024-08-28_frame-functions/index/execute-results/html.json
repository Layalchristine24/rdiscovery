{
  "hash": "76d24e90d5530e1bab4982e4d22a8db1",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: How can you use the *frame functions from the package tibble?\nauthor:\n  - name:\n      given: Layal Christine\n      family: Lettry\n      orcid: 0009-0008-6396-0523\n    affiliations:\n      - id: cynkra\n      - name: cynkra GmbH\n        city: Zurich\n        state: CH\n      - id: unifr\n      - name: University of Fribourg, Dept. of Informatics, ASAM Group\n        city: Fribourg\n        state: CH\ndate: 2024-08-28\ncategories: [dplyr, constructive, tibble, enframe, deframe, nested]\nimage: image.jpg\ncitation: \n  url: https://rdiscovery.netlify.app/posts/2024-08-28_frame-functions/\nformat:\n  html:\n    toc: true\n    toc-depth: 6\n    toc-title: Contents\n    toc-location: right\n    number-sections: false\neditor_options: \n  chunk_output_type: console\n---\n\n\n\n*In which case can you use `enframe` and `deframe`?*\n\n# Initial object\n\nLet's assume that we have a numeric vector and a list.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_vec <- c(\"first\" = 1L, \"second\" = 2L, \"third\" = 3L)\nconstructive::construct(my_vec)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nc(first = 1L, second = 2L, third = 3L)\n```\n\n\n:::\n\n```{.r .cell-code}\nmy_list <- list(my_vec = my_vec)\nconstructive::construct(my_list)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nlist(my_vec = c(first = 1L, second = 2L, third = 3L))\n```\n\n\n:::\n:::\n\n\n\n# Use `enframe()` from tibble\n\nLet's say we need to convert our vector and our list to tibbles. \nWe can use the function `enframe()` from the tibble package to achieve this.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_tib_vec <- tibble::enframe(my_vec)\nconstructive::construct(my_tib_vec)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ntibble::tibble(name = c(\"first\", \"second\", \"third\"), value = 1:3)\n```\n\n\n:::\n\n```{.r .cell-code}\nmy_tib_list <- tibble::enframe(my_list)\nconstructive::construct(my_tib_list)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ntibble::tibble(name = \"my_vec\", value = list(c(first = 1L, second = 2L, third = 3L)))\n```\n\n\n:::\n:::\n\n\n\nWe can see that `my_tib_vec` and `my_tib_list` are not the same. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwaldo::compare(my_tib_vec, my_tib_list)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n`attr(old, 'row.names')`: 1 2 3\n`attr(new, 'row.names')`: 1    \n\n`old$name`: \"first\"  \"second\" \"third\"\n`new$name`: \"my_vec\"                 \n\n`old$value` is an integer vector (1, 2, 3)\n`new$value` is a list\n```\n\n\n:::\n:::\n\n\n\nThis difference comes from the fact that the `enframe()` function converts a named vector into a regular tibble, while a list will be transformed into a nested[^nested_tib_posts] tibble.\n\n[^nested_tib_posts]: You can refer to my former blog posts [What is the difference between (un)packing and (un)nesting a tibble?](https://rdiscovery.netlify.app/posts/2024-05-30_pack-nest/) and [What are the use cases for using nested data over packed data?](https://rdiscovery.netlify.app/posts/2024-06-03_use-case-pack-nest/).\n\nTo obtain the same tibbles, we need to perform operations on the nested tibble. \nFirst, we need to unlist the `value` variable and to enframe it in a list to retrieve the name of each element. \nEventually, we can unnest the column `value`.\n\nNote that we remove the initial `name` column which contained the name of the list, namely `my_vec`, to only keep the `name` variable corresponding to the names of the list values, i.e. `\"first\"`, `\"second\"` and `\"third\"`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_unnested_tib_list <-\n  my_tib_list |>\n  dplyr::mutate(value = list(tibble::enframe(unlist(my_tib_list$value)))) |>\n  dplyr::select(-name) |>\n  tidyr::unnest(cols = value)\n\nconstructive::construct(my_unnested_tib_list)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ntibble::tibble(name = c(\"first\", \"second\", \"third\"), value = 1:3)\n```\n\n\n:::\n\n```{.r .cell-code}\nwaldo::compare(my_tib_vec, my_unnested_tib_list)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n✔ No differences\n```\n\n\n:::\n:::\n\n\n\n# Use `deframe()` from tibble\n\nTo recover our original vector and list, we can use `deframe()` from tibble.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_original_vec <- tibble::deframe(my_tib_vec)\nconstructive::construct(my_original_vec)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nc(first = 1L, second = 2L, third = 3L)\n```\n\n\n:::\n\n```{.r .cell-code}\nwaldo::compare(my_vec, my_original_vec)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n✔ No differences\n```\n\n\n:::\n\n```{.r .cell-code}\nmy_original_list <- tibble::deframe(my_tib_list)\nconstructive::construct(my_original_list)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nlist(my_vec = c(first = 1L, second = 2L, third = 3L))\n```\n\n\n:::\n\n```{.r .cell-code}\nwaldo::compare(my_list, my_original_list)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n✔ No differences\n```\n\n\n:::\n:::\n\n\n\nNote that the nested tibble is automatically converted to a list thanks to `deframe()`.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}