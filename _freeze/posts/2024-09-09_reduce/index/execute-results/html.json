{
  "hash": "a65f90837f1b74974384ed1e6fdea28d",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: How do you iterate a vector?\nauthor:\n  - name:\n      given: Layal Christine\n      family: Lettry\n      orcid: 0009-0008-6396-0523\n    affiliations:\n      - id: cynkra\n      - name: cynkra GmbH\n        city: Zurich\n        state: CH\n      - id: unifr\n      - name: University of Fribourg, Dept. of Informatics, ASAM Group\n        city: Fribourg\n        state: CH\ndate: 2024-09-09\ncategories: [purrr, constructive, reduce, accumulate, loop, iteration]\nimage: image.jpg\ncitation: \n  url: https://rdiscovery.netlify.app/posts/2024-09-09_reduce/\nformat:\n  html:\n    toc: true\n    toc-depth: 6\n    toc-title: Contents\n    toc-location: right\n    number-sections: false\neditor_options: \n  chunk_output_type: console\n---\n\n\n\n*What functions can you use to replace a loop?*\n\n# Initial object\n\nLet's assume that we have a numeric vector.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_vec <- c(\"first\" = 1L, \"second\" = 2L, \"third\" = 3L, \"fourth\" = 4L)\nconstructive::construct(my_vec)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nc(first = 1L, second = 2L, third = 3L, fourth = 4L)\n```\n\n\n:::\n:::\n\n\n\n# Use `reduce()` from purrr\n\nLet's say we want to compute the sum and the product of all the elements of our vector.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_vec |>\n  purrr::reduce(`+`)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10\n```\n\n\n:::\n\n```{.r .cell-code}\nmy_vec |>\n  purrr::reduce(`*`)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 24\n```\n\n\n:::\n:::\n\n\n\nIt is the same as doing\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_vec |> sum()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10\n```\n\n\n:::\n\n```{.r .cell-code}\nmy_vec |> prod()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 24\n```\n\n\n:::\n:::\n\n\n\nWe could also write a loop for the sum, which would perform exactly the same operations as `reduce()`, but in a more complicated way.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Define the function f\nf <- function(x, y) {\n  x + y\n}\n\n# Start with the first value\nmy_vec <- unname(my_vec)\nresult <- my_vec[1]\n\n# Loop through the rest of the values\nfor (i in 2:length(my_vec)) {\n  result <- f(result, my_vec[i])\n}\n\nprint(result)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10\n```\n\n\n:::\n:::\n\n\n\nThese results show that `reduce()` takes the vector values and applies the `+` or `*` function iteratively in the `forward` direction (default).\n\n## Difference between the forward and the backward direction\n\nLet the function `f` be defined by `f(a, b) = a + b`. Then, `reduce()` will apply this to `my_vec`, i.e.\n\n$$\nf(f(f(1, 2), 3), 4) = f(f(3, 3), 4) = f(6, 4) = 10.\n$$\n\nIf the direction had been set `backwards`, the following would have occurred:\n\n$$\nf(f(f(4, 3), 2), 1) = f(f(7, 2), 1) = f(9, 1) = 10.\n$$ \n\nTo see the difference between `forward` and `backward`, let's subtract the elements of our vector iteratively.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_vec |>\n  purrr::reduce(`-`)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] -8\n```\n\n\n:::\n\n```{.r .cell-code}\nmy_vec |>\n  purrr::reduce(`-`, .dir = \"backward\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] -2\n```\n\n\n:::\n:::\n\n\n\nLet the function `g` be defined by `g(a, b) = a - b`. Then, the `forward` subtraction corresponds to this operation:\n\n$$\ng(g(g(1, 2), 3), 4) = g(g(-1, 3), 4) = g(-4, 4) = -8. \n$$\n\nThe the `backward` subtraction would be:\n\n$$ \ng(g(g(4, 3), 2), 1) = g(g(1, 2), 1) = g(-1, 1) = -2.\n$$\n\n## Initial value of the accumulation\n\nWe could set the initial value of the accumulation.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_vec[[3]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n```\n\n\n:::\n\n```{.r .cell-code}\nmy_vec |>\n  purrr::reduce(`-`, .init = my_vec[[3]])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] -7\n```\n\n\n:::\n:::\n\n\n\nHere, there is one additional argument and the iteration starts with the value of `3` that corresponds to `my_vec[[3]]`:\n\n$$\ng(g(g(g(3, 1), 2), 3), 4) = g(g(g(2, 2), 3), 4) = g(g(0, 3), 4) = g(-3, 4) = -7.\n$$\n\n## Apply a predefined function iteratively\n\n### With two arguments\n\nLet's say we want to compute the empiric variance for our vector.\n\nWe usually compute it with `var(my_vec) =` 1.6666667. This is an unbiased estimator of the variance because the denominator is `n-1 = length(my_vec) - 1 =` 3. The following operation:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n1 / (length(my_vec) - 1) * sum((my_vec - mean(my_vec))^2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.666667\n```\n\n\n:::\n:::\n\n\n\ncorresponds to\n\n$$ \n1/(n-1) \\sum_{i = 1}^n (x_i - \\bar{x})^2.\n$$ However, it does not work when we try to apply this formula using `reduce()`, because we need to supply two arguments.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# does not work\nmy_vec |>\n  purrr::reduce(\\(x) 1 / (length(x) - 1) * sum((x - mean(x))^2))\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in fn(out, elt, ...): unused argument (elt)\n```\n\n\n:::\n:::\n\n\n\nLet's do it by entering two arguments into the `reduce()` function.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# works but is not the variance of my_vec\nmy_vec |>\n  purrr::reduce(\\(x, y) var(c(x, y)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.3828125\n```\n\n\n:::\n\n```{.r .cell-code}\n# or\nmy_var <- function(x, y) {\n  1 / (length(c(x, y)) - 1) * sum((c(x, y) - mean(c(x, y)))^2)\n}\nmy_vec |>\n  purrr::reduce(\\(x, y) my_var(x, y))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.3828125\n```\n\n\n:::\n:::\n\n\n\nSo, what does `reduce()` compute?\n\nLet $x =$ `my_vec` and $h(x_1, x_2)$ be a function defined by\n\n$$\nh(x_1, x_2) = var(x_1, x_2) = 1/(2-1) \\sum_{i = 1}^2 (x_i - \\bar{x})^2 = \\left[x_1 - \\frac{(x_1 + x_2)}{2}\\right]^2 + \\left[x_2 - \\frac{(x_1 + x_2)}{2}\\right]^2.\n$$ Thus, we get 0.3828125 because `reduce()` computes $h(h(h(1, 2), 3), 4)$ which is equal to\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvar(c(var(c(var(my_vec[1:2]), my_vec[3])), my_vec[4]))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.3828125\n```\n\n\n:::\n\n```{.r .cell-code}\n# or\n\nmy_var(my_var(my_var(my_vec[[1]], my_vec[[2]]), my_vec[[3]]), my_vec[[4]])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.3828125\n```\n\n\n:::\n:::\n\n\n\n### With three arguments\n\nIf `.init` is not specified, the function `reduce2()` takes as arguments a first vector and a second one which is shorter than the former by one element. Otherwise, both arguments should have the same number of of elements.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_x <- my_vec\nmy_y <- my_vec\n\npurrr::reduce2(my_x, my_y, paste, .init = 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"5 1 1 2 2 3 3 4 4\"\n```\n\n\n:::\n\n```{.r .cell-code}\nmy_x <- my_vec |> unname()\nmy_y <- my_x[-length(my_x)] + 6\n\npurrr::reduce2(my_x, my_y, paste)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"1 2 7 3 8 4 9\"\n```\n\n\n:::\n:::\n\n\n\nIf `.init` is not specified, the `reduce2()` function takes as the initial value the first element of the first argument. \n\nOtherwise, the argument `.init` gives the first element. This is the first argument. \n\nThen, the values going from the first non-used element of the two arguments (here `my_x` and `my_y`) will be the second and the third elements.\n\n# Use `accumulate()` from purrr\n\nThe function `accumulate()` will give the intermediate results of the `reduce()` function.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_vec |>\n  purrr::accumulate(`+`)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  1  3  6 10\n```\n\n\n:::\n\n```{.r .cell-code}\nmy_vec |>\n  purrr::accumulate(`*`)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  1  2  6 24\n```\n\n\n:::\n\n```{.r .cell-code}\nmy_vec |>\n  purrr::accumulate(\\(x, y) var(c(x, y)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.0000000 0.5000000 3.1250000 0.3828125\n```\n\n\n:::\n:::\n\n\n\nYou can alsow use `accumulate2()` if you use 2 lists.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_x <- my_vec\nmy_y <- my_vec\n\npurrr::accumulate2(my_x, my_y, paste, .init = 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] 5\n\n[[2]]\n[1] \"5 1 1\"\n\n[[3]]\n[1] \"5 1 1 2 2\"\n\n[[4]]\n[1] \"5 1 1 2 2 3 3\"\n\n[[5]]\n[1] \"5 1 1 2 2 3 3 4 4\"\n```\n\n\n:::\n\n```{.r .cell-code}\nmy_x <- my_vec |> unname()\nmy_y <- my_x[-length(my_x)] + 6\n\npurrr::accumulate2(my_x, my_y, paste)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] 1\n\n[[2]]\n[1] \"1 2 7\"\n\n[[3]]\n[1] \"1 2 7 3 8\"\n\n[[4]]\n[1] \"1 2 7 3 8 4 9\"\n```\n\n\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}