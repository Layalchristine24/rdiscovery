{
  "hash": "1d5ca2e36ca4bff2ff5586284c49d806",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: What is the difference between (un)packing and (un)nesting a tibble?\nauthor:\n  - name:\n      given: Layal Christine\n      family: Lettry\n      orcid: 0009-0008-6396-0523\n    affiliations:\n      - id: cynkra\n      - name: cynkra GmbH\n        city: Zurich\n        state: CH\n      - id: unifr\n      - name: University of Fribourg, Dept. of Informatics, ASAM Group\n        city: Fribourg\n        state: CH\ndate: 2024-05-30\ncategories: [nest, unnest, pack, unpack, tidyr, constructive]\nimage: image.jpg\ncitation: \n  url: https://rdiscovery.netlify.app/posts/2024-05-30_pack-nest/\nformat:\n  html:\n    toc: true\n    toc-depth: 6\n    toc-title: Contents\n    toc-location: right\n    number-sections: false\neditor_options: \n  chunk_output_type: console\n---\n\n\n*What is the difference between (un)packing and (un)nesting a tibble?*\n\n# Initial object\n\nLet's assume that `my_tib` is a nested tibble containing a list, namely `my_values`, with another tibble where the variables are `my_ints` and `my_chars`. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_tib <-\n  tibble::tibble(\n    my_values = list(tibble::tibble(\n      my_ints = 1L:5L,\n      my_chars = LETTERS[my_ints]\n    ))\n  )\nconstructive::construct(my_tib)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ntibble::tibble(\n  my_values = list(tibble::tibble(my_ints = 1:5, my_chars = c(\"A\", \"B\", \"C\", \"D\", \"E\"))),\n)\n```\n\n\n:::\n:::\n\n\nWe could also use `tidyr::nest()` to create `my_tib` (please refer to [this article](https://tidyr.tidyverse.org/articles/nest.html) for more info).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_nested_tib <-\n  tibble::tribble(\n    ~my_ints, ~my_chars,\n    1L, \"A\",\n    2L, \"B\",\n    3L, \"C\",\n    4L, \"D\",\n    5L, \"E\"\n  ) |>\n  tidyr::nest(my_values = c(my_ints, my_chars))\n\nconstructive::construct(my_nested_tib)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ntibble::tibble(\n  my_values = list(tibble::tibble(my_ints = 1:5, my_chars = c(\"A\", \"B\", \"C\", \"D\", \"E\"))),\n)\n```\n\n\n:::\n:::\n\n\nAs you can see, there is no difference between `my_tib` and `my_nested_tib`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwaldo::compare(my_tib, my_nested_tib)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nâœ” No differences\n```\n\n\n:::\n:::\n\n\n# What if we do not want any nested tibble?\nIn this case, we should pack the variables `my_ints` and `my_chars` together so that we have a tibble in another tibble instead of a list with an element that is a tibble.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_packed_tib <-\n  tibble::tribble(\n    ~my_ints, ~my_chars,\n    1L, \"A\",\n    2L, \"B\",\n    3L, \"C\",\n    4L, \"D\",\n    5L, \"E\"\n  ) |>\n  tidyr::pack(my_values = c(my_ints, my_chars))\nconstructive::construct(my_packed_tib)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ntibble::tibble(\n  my_values = tibble::tibble(my_ints = 1:5, my_chars = c(\"A\", \"B\", \"C\", \"D\", \"E\")),\n)\n```\n\n\n:::\n:::\n\n\nWe can assess the difference between `my_nested_tib` and `my_packed_tib` with `waldo::compare()`. \n\n::: {.cell}\n\n```{.r .cell-code}\nwaldo::compare(my_nested_tib, my_packed_tib)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n`attr(old, 'row.names')`: 1        \n`attr(new, 'row.names')`: 1 2 3 4 5\n\n`old$my_values` is a list\n`new$my_values` is an S3 object of class <tbl_df/tbl/data.frame>, a list\n```\n\n\n:::\n:::\n\n\nThis tells us that `my_nested_tib` has only one row and contains the variable `my_values` that is a list, whereas `my_packed_tib` has 5 rows and is constituted by the variable `my_values` that is in this case a data frame. \nFor the record, a data frame is a special list where every element has the same lenght.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}