---
title: What are the use cases of using nested versus packed data?
author:
  - name:
      given: Layal Christine
      family: Lettry
      orcid: 0009-0008-6396-0523
    affiliations:
      - id: cynkra
      - name: cynkra GmbH
        city: Zurich
        state: CH
      - id: unifr
      - name: University of Fribourg, Dept. of Informatics, ASAM Group
        city: Fribourg
        state: CH
date: 2024-05-30
categories: [nest, unnest, pack, unpack, tidyr, json, constructive]
image: image.jpg
citation: 
  url: https://rdiscovery.netlify.app/posts/2024-06-01_use-case-pack-nest/
format:
  html:
    toc: true
    toc-depth: 6
    toc-title: Contents
    toc-location: right
    number-sections: false
editor_options: 
  chunk_output_type: console
---

*When would you use nested instead packed data (and vice versa)?*

In my last [blog post](https://rdiscovery.netlify.app/posts/2024-05-30_pack-nest/), we could see what the difference was between the structure of nested data opposite to packed data. 

In this article, I would like to show when we could use nested and packed data.

# Nested data

In the following example, we can nest data from the tibble `palmerpenguins::penguins` to the raw data `palmerpenguins::penguins_raw`.


```{r}
my_nested_tib <-
  palmerpenguins::penguins |>
  dplyr::distinct(island) |>
  dplyr::rename(my_island = island) |>
  dplyr::mutate(
    penguins_data = purrr::map(
      my_island, \(x) dplyr::filter(palmerpenguins::penguins, island == x)
    ),
    penguins_raw_data = purrr::map(
      my_island, \(x) dplyr::filter(palmerpenguins::penguins_raw, Island == x)
    )
  ) |> 
  dplyr::select(-my_island) 

dplyr::glimpse(my_nested_tib)
```

We can see that `palmerpenguins::penguins` and `palmerpenguins::penguins_raw` have different dimensions.
They have the same number of rows but a different number of columns.

To unlist our data, we can unnest the columns `penguins_data` and `penguins_raw_data`.

```{r}
my_unnested_tib <-
  my_nested_tib |>
  tidyr::unnest(
    cols = c(penguins_data, penguins_raw_data)
  )
dplyr::glimpse(my_unnested_tib)
```


# Packed data

You would need to pack data to group similar variables, so that you can easily compare them. 
Opposite to `my_unnested_tib`, our tibble `my_packed_data` will be narrow because similar columns will be collapsed into a single variable. 
You can find more information about the packing process in this [article](https://tidyr.tidyverse.org/reference/pack.html).

```{r}
my_packed_data <-
  my_unnested_tib |>
  tidyr::pack(
    all_species = c(species, Species),
    all_island = c(island, Island),
    all_bill_length_mm = c(bill_length_mm, `Culmen Length (mm)`),
    all_bill_depth_mm = c(bill_depth_mm, `Culmen Depth (mm)`),
    all_flipper_length_mm = c(flipper_length_mm, `Flipper Length (mm)`),
    all_body_mass_g = c(body_mass_g, `Body Mass (g)`),
    all_sex = c(sex, Sex),
    all_date = c(year, `Date Egg`),
    all_remaining_raw_data = c(
      studyName, `Sample Number`, Region, Stage, `Individual ID`,
      `Clutch Completion`, `Delta 15 N (o/oo)`, `Delta 13 C (o/oo)`,
      Comments
    )
  )
dplyr::glimpse(my_packed_data)
```

Now, `my_packed_data` is a tibble with 9 columns instead of 25 for `my_unnested_tib`.

You can subset it either by using the dollar sign `$` or the brackets `[[]]`.
For example, you could write `my_packed_data$all_body_mass_g$body_mass_g`, `my_packed_data$all_body_mass_g[["body_mass_g"]]` or `my_packed_data[["all_body_mass_g"]][["body_mass_g"]]`.
This will give you the same result.
```{r}
waldo::compare(
  my_packed_data$all_body_mass_g$body_mass_g, 
  my_packed_data$all_body_mass_g[["body_mass_g"]])

waldo::compare(
  my_packed_data$all_body_mass_g$body_mass_g, 
  my_packed_data[["all_body_mass_g"]][["body_mass_g"]])
```

Furthermore, it is so organised that you easily can analyse the differences between `palmerpenguins::penguins` and `palmerpenguins::penguins_raw`.

```{r}
# Species from penguins_raw and species from penguins (old vs new) 
waldo::compare(my_packed_data$all_species$Species, 
               my_packed_data$all_species$species)

# Island from penguins_raw and island from penguins (old vs new) 
waldo::compare(my_packed_data$all_island$Island, 
               my_packed_data$all_island$island)

# `Culmen Length (mm)` from penguins_raw and bill_length_mm from penguins (old vs new) 
waldo::compare(my_packed_data$all_bill_length_mm$`Culmen Length (mm)`, 
               my_packed_data$all_bill_length_mm$bill_length_mm)
```

You can also easily get the columns `palmerpenguins::penguins_raw` which were not included into ``palmerpenguins::penguins` and unpack them.

```{r}
my_raw_additional_columns <- 
my_packed_data |> 
  dplyr::select(all_remaining_raw_data) |> 
  tidyr::unpack(all_remaining_raw_data)

dplyr::glimpse(my_raw_additional_columns)
```
