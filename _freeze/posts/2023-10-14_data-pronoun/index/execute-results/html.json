{
  "hash": "d481f28cafc6c62a91bd107afefe1f2b",
  "result": {
    "markdown": "---\ntitle: \"Perform transformations on several variables with `.env` and `.data` pronouns\"\nauthor: \"Layal C. Lettry\"\ndate: \"2023-10-15\"\ncategories: [rlang, pronouns, magrittr]\nimage: \"image.jpg\"\n---\n\n\n# Problem\n\nLet's assume that you would like to know the number of occurrences for each instance of the following data.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmydata <- tibble::tribble(\n  ~year,      ~country, ~age, ~is_married, ~has_child, ~is_woman,\n   1990,      \"France\",   68,        TRUE,      FALSE,      TRUE,\n   1990,      \"France\",   22,       FALSE,      FALSE,      TRUE,\n   1990,       \"Italy\",   28,       FALSE,       TRUE,     FALSE,\n   1990,       \"Italy\",   56,        TRUE,       TRUE,     FALSE,\n   1990,       \"Italy\",   36,        TRUE,       TRUE,     FALSE,\n   1990, \"Switzerland\",   23,       FALSE,       TRUE,      TRUE,\n   1990, \"Switzerland\",   23,       FALSE,      FALSE,     FALSE,\n   2000,      \"France\",   13,       FALSE,      FALSE,      TRUE,\n   2000,      \"France\",   63,        TRUE,       TRUE,     FALSE,\n   2000,       \"Italy\",   43,        TRUE,      FALSE,     FALSE,\n   2000, \"Switzerland\",   42,        TRUE,       TRUE,      TRUE,\n   2000, \"Switzerland\",   32,        TRUE,      FALSE,      TRUE\n  )\n\nmydata\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 12 × 6\n    year country       age is_married has_child is_woman\n   <dbl> <chr>       <dbl> <lgl>      <lgl>     <lgl>   \n 1  1990 France         68 TRUE       FALSE     TRUE    \n 2  1990 France         22 FALSE      FALSE     TRUE    \n 3  1990 Italy          28 FALSE      TRUE      FALSE   \n 4  1990 Italy          56 TRUE       TRUE      FALSE   \n 5  1990 Italy          36 TRUE       TRUE      FALSE   \n 6  1990 Switzerland    23 FALSE      TRUE      TRUE    \n 7  1990 Switzerland    23 FALSE      FALSE     FALSE   \n 8  2000 France         13 FALSE      FALSE     TRUE    \n 9  2000 France         63 TRUE       TRUE      FALSE   \n10  2000 Italy          43 TRUE       FALSE     FALSE   \n11  2000 Switzerland    42 TRUE       TRUE      TRUE    \n12  2000 Switzerland    32 TRUE       FALSE     TRUE    \n```\n:::\n:::\n\n## The `.env` pronoun\n\nLet's say we also want to have a variable called `is_parent` which can be deduced from the variable `has_child`. We can define the default value `TRUE` for `is_parent` and make it dependent of the `has_child`. This default variable can be retrieved with the `.env` pronoun.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nis_parent <- TRUE\n\nparent_data <- \n  mydata |>\n    dplyr::mutate(is_parent = as.logical(has_child * .env$is_parent)) \n\nparent_data\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 12 × 7\n    year country       age is_married has_child is_woman is_parent\n   <dbl> <chr>       <dbl> <lgl>      <lgl>     <lgl>    <lgl>    \n 1  1990 France         68 TRUE       FALSE     TRUE     FALSE    \n 2  1990 France         22 FALSE      FALSE     TRUE     FALSE    \n 3  1990 Italy          28 FALSE      TRUE      FALSE    TRUE     \n 4  1990 Italy          56 TRUE       TRUE      FALSE    TRUE     \n 5  1990 Italy          36 TRUE       TRUE      FALSE    TRUE     \n 6  1990 Switzerland    23 FALSE      TRUE      TRUE     TRUE     \n 7  1990 Switzerland    23 FALSE      FALSE     FALSE    FALSE    \n 8  2000 France         13 FALSE      FALSE     TRUE     FALSE    \n 9  2000 France         63 TRUE       TRUE      FALSE    TRUE     \n10  2000 Italy          43 TRUE       FALSE     FALSE    FALSE    \n11  2000 Switzerland    42 TRUE       TRUE      TRUE     TRUE     \n12  2000 Switzerland    32 TRUE       FALSE     TRUE     FALSE    \n```\n:::\n:::\n\n\n## With a for loop\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (var in names(parent_data)) {\n  parent_data |>\n    dplyr::count(.data[[var]]) |>\n    print()\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 2\n   year     n\n  <dbl> <int>\n1  1990     7\n2  2000     5\n# A tibble: 3 × 2\n  country         n\n  <chr>       <int>\n1 France          4\n2 Italy           4\n3 Switzerland     4\n# A tibble: 11 × 2\n     age     n\n   <dbl> <int>\n 1    13     1\n 2    22     1\n 3    23     2\n 4    28     1\n 5    32     1\n 6    36     1\n 7    42     1\n 8    43     1\n 9    56     1\n10    63     1\n11    68     1\n# A tibble: 2 × 2\n  is_married     n\n  <lgl>      <int>\n1 FALSE          5\n2 TRUE           7\n# A tibble: 2 × 2\n  has_child     n\n  <lgl>     <int>\n1 FALSE         6\n2 TRUE          6\n# A tibble: 2 × 2\n  is_woman     n\n  <lgl>    <int>\n1 FALSE        6\n2 TRUE         6\n# A tibble: 2 × 2\n  is_parent     n\n  <lgl>     <int>\n1 FALSE         6\n2 TRUE          6\n```\n:::\n:::\n\n\n\n## With the function `purrr::map()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nparent_data |>\n  names() |>\n  purrr::map(\\(.x) dplyr::count(parent_data, .data[[.x]]))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n# A tibble: 2 × 2\n   year     n\n  <dbl> <int>\n1  1990     7\n2  2000     5\n\n[[2]]\n# A tibble: 3 × 2\n  country         n\n  <chr>       <int>\n1 France          4\n2 Italy           4\n3 Switzerland     4\n\n[[3]]\n# A tibble: 11 × 2\n     age     n\n   <dbl> <int>\n 1    13     1\n 2    22     1\n 3    23     2\n 4    28     1\n 5    32     1\n 6    36     1\n 7    42     1\n 8    43     1\n 9    56     1\n10    63     1\n11    68     1\n\n[[4]]\n# A tibble: 2 × 2\n  is_married     n\n  <lgl>      <int>\n1 FALSE          5\n2 TRUE           7\n\n[[5]]\n# A tibble: 2 × 2\n  has_child     n\n  <lgl>     <int>\n1 FALSE         6\n2 TRUE          6\n\n[[6]]\n# A tibble: 2 × 2\n  is_woman     n\n  <lgl>    <int>\n1 FALSE        6\n2 TRUE         6\n\n[[7]]\n# A tibble: 2 × 2\n  is_parent     n\n  <lgl>     <int>\n1 FALSE         6\n2 TRUE          6\n```\n:::\n:::\n\n\n# What is the difference between the `.data` and the `.env` pronouns?\n\nThe `.env` pronoun allows to use variables which were previously defined in the environment, whereas the `.data` pronoun takes the variables which are in the data frame.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbody_mass_g <- palmerpenguins::penguins$body_mass_g\nbody_mass_g[is.na(body_mass_g)] <- 4209\n\npalmerpenguins::penguins |>\n  dplyr::select(body_mass_g) |>\n  dplyr::mutate(\n    body_mass_kg_env = .env$body_mass_g / 1e3,\n    body_mass_kg_data = .data$body_mass_g / 1e3\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 344 × 3\n   body_mass_g body_mass_kg_env body_mass_kg_data\n         <int>            <dbl>             <dbl>\n 1        3750             3.75              3.75\n 2        3800             3.8               3.8 \n 3        3250             3.25              3.25\n 4          NA             4.21             NA   \n 5        3450             3.45              3.45\n 6        3650             3.65              3.65\n 7        3625             3.62              3.62\n 8        4675             4.68              4.68\n 9        3475             3.48              3.48\n10        4250             4.25              4.25\n# ℹ 334 more rows\n```\n:::\n:::\n\n\n\n# What is the difference between the `.data` and the magrittr `.` pronouns?\n\nI learnt in this [article's section](https://rlang.r-lib.org/reference/dot-data.html) that it is safer to use the rlang `.data` pronoun than the magrittr `.` one in a data-masked context. With grouped data, `.` relates to the whole data whereas `.data` represents the current sliced data.\n\nThe `.data` pronoun is automatically generated when you use [data-masking functions](https://rlang.r-lib.org/reference/topic-data-mask-ambiguity.html#:~:text=Data%20masking%20is%20an%20R,defined%20in%20the%20current%20environment).\n\n# References\n\nThe previous code and explanations are inspired from:\n\n- <https://dplyr.tidyverse.org/articles/programming.html#loop-over-multiple-variables>,\n\n- <https://rlang.r-lib.org/reference/dot-data.html>.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}