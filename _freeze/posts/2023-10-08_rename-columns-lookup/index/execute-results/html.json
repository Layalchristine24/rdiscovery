{
  "hash": "365cd9ce02c8bb7de951a702fede5f55",
  "result": {
    "markdown": "---\ntitle: Rename variables in a data frame using an external lookup table\nauthor: \n  - name:\n      given: Layal Christine\n      family: Lettry\n      orcid: 0009-0008-6396-0523\n    affiliations:\n      - id: cynkra\n      - name: cynkra GmbH\n        city: Zurich\n        state: CH\n      - id: unifr\n      - name: University of Fribourg, Dept. of Informatics, ASAM Group\n        city: Fribourg\n        state: CH\ndate: 2023-10-08\ncategories: [unquote-splice, tidy evaluation, rename, any_of]\nimage: image.jpg\ncitation: \n  url: https://rdiscovery.netlify.app/posts/2023-10-08_rename-columns-lookup/\nformat:\n  html:\n    toc: true\n    toc-title: Contents\n    toc-location: right\n    number-sections: false\n---\n\n\n*Addressing the challenge of renaming multiple variables through an external lookup table using tidy evaluation techniques*\n\n# Problem\n\nLet's assume that a data frame is present with certain columns that possess the appropriate names, however, the remaining columns require renaming. An existing lookup table is ready to be used for setting new names to these specific columns.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n:::\n\n\nHere is the data frame with 3 variables, namely `var1`, `var2` and `var4`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntest_tib <- tribble(\n  ~var1,      ~var2,   ~var4,\n  \"x\",        \"a\",     1L,\n  \"y\",        \"b\",     2L,\n  \"z\",        \"c\",     3L\n)\ntest_tib\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 3\n  var1  var2   var4\n  <chr> <chr> <int>\n1 x     a         1\n2 y     b         2\n3 z     c         3\n```\n:::\n:::\n\n\nDefine the lookup table with the new names. Transform this lookup table into a named vector using `deframe()`. Do not forget that the first argument of `deframe()` should be the new names of the variable and the second one should have the actual names.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnew_names <- tribble(\n  ~names_var, ~new_names_var,\n  \"var1\",     \"Variable 1\",\n  \"var2\",     \"Variable 2\",\n  \"var3\",     \"Variable 3\",\n  \"var4\",     \"Variable 4\"\n)\nnew_names\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 × 2\n  names_var new_names_var\n  <chr>     <chr>        \n1 var1      Variable 1   \n2 var2      Variable 2   \n3 var3      Variable 3   \n4 var4      Variable 4   \n```\n:::\n\n```{.r .cell-code}\nnew_names_vec <- deframe(select(new_names, new_names_var, names_var))\nnew_names_vec\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nVariable 1 Variable 2 Variable 3 Variable 4 \n    \"var1\"     \"var2\"     \"var3\"     \"var4\" \n```\n:::\n:::\n\n\n# Solution\n\nWe can solve this using tidy evaluation tools, namely the unquote-splice `!!!`, or the dplyr functions `any_of()`. Reading the [article written by Tim Tiefenbach](https://tim-tiefenbach.de/post/2022-rename-columns/#dplyr-tidyverse), I was able to come up with the solutions below.\n\n## Using `!!!`\n\nOur goal is to unpack the vector of column name pairs that are actually in our data frame. We could achieve this by using unquote-splice `!!!` which will splice the list of names into the dynamic dots `...` of `rename()`.\n\nHowever, the column `var3` is not found. An error appears.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntest_tib |>\n  rename(!!!new_names_vec)\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in `rename()`:\n! Can't rename columns that don't exist.\n✖ Column `var3` doesn't exist.\n```\n:::\n:::\n\n\nSelect only the variables which are in the named vector `new_names_vec`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntest_tib |>\n  rename(!!!new_names_vec[new_names_vec %in% names(test_tib)])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 3\n  `Variable 1` `Variable 2` `Variable 4`\n  <chr>        <chr>               <int>\n1 x            a                       1\n2 y            b                       2\n3 z            c                       3\n```\n:::\n:::\n\n\n## Using `any_of()`\n\nInstead of selecting the common variables, you can use `any_of()` which does this selection automatically.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntest_tib |>\n  rename(any_of(new_names_vec))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 3\n  `Variable 1` `Variable 2` `Variable 4`\n  <chr>        <chr>               <int>\n1 x            a                       1\n2 y            b                       2\n3 z            c                       3\n```\n:::\n:::\n\n\n# References\n\nThese examples are inspired by:\n\n-   [Article written by Tim Tiefenbach](https://tim-tiefenbach.de/post/2022-rename-columns/#dplyr-tidyverse),\n\n-   <https://dcl-prog.stanford.edu/tidy-eval-detailed.html>,\n\n-   <https://adv-r.hadley.nz/quasiquotation.html#unquoting-many-arguments>,\n\n-   <https://rlang.r-lib.org/reference/topic-inject.html#splicing-with--1>,\n\n-   <https://rlang.r-lib.org/reference/dyn-dots.html>.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}