{
  "hash": "e90b6640d16782cd2107f6204328cb19",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: How to filter values in a nested tibble without using `filter()` from dplyr?\nauthor:\n  - name:\n      given: Layal Christine\n      family: Lettry\n      orcid: 0009-0008-6396-0523\n    affiliations:\n      - id: cynkra\n      - name: cynkra GmbH\n        city: Zurich\n        state: CH\n      - id: unifr\n      - name: University of Fribourg, Dept. of Informatics, ASAM Group\n        city: Fribourg\n        state: CH\ndate: 2024-05-20\ncategories: [dplyr, arrow, nested, purrr, constructive]\nimage: image.jpg\ncitation: \n  url: https://rdiscovery.netlify.app/posts/2024-05-20_filter-nested-tibble/\nformat:\n  html:\n    toc: true\n    toc-depth: 6\n    toc-title: Contents\n    toc-location: right\n    number-sections: false\neditor_options: \n  chunk_output_type: console\n---\n\n\n*How to filter values in a nested tibble?*\n\n\n# Object\n\nRecently, I have been working with arrow objects. \nI came across the following object, retrieved using the function `constructive::construct()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_tib <-\n  tibble::tibble(\n    my_data = vctrs::list_of(\n      tibble::tibble(\n        year = vctrs::list_of(2018:2022, .ptype = integer(0)) |>\n          structure(class = c(\"arrow_list\", \"vctrs_list_of\", \"vctrs_vctr\", \"list\")),\n        records = vctrs::list_of(\n          tibble::tibble(\n            category = c(\n              \"categ1\", \"categ2\", \"categ3\", \"categ4\", \"categ5\", \"categ6\",\n              \"categ7\"\n            ),\n            values = vctrs::list_of(\n              c(100, 110, 120, 130, 140),\n              c(200, 210, 220, 230, 240),\n              c(300, 310, 320, 330, 340),\n              c(400, 410, 420, 430, 440),\n              c(500, 510, 520, 530, 540),\n              c(600, 610, 620, 630, 640),\n              c(700, 710, 720, 730, 740),\n              .ptype = numeric(0)\n            ) |>\n              structure(class = c(\"arrow_list\", \"vctrs_list_of\", \"vctrs_vctr\", \"list\")),\n          ),\n          .ptype = tibble::tibble(\n            category = character(0),\n            values = vctrs::list_of(.ptype = numeric(0)) |>\n              structure(class = c(\"arrow_list\", \"vctrs_list_of\", \"vctrs_vctr\", \"list\")),\n          )\n        ) |>\n          structure(class = c(\"arrow_list\", \"vctrs_list_of\", \"vctrs_vctr\", \"list\")),\n      ),\n      .ptype = tibble::tibble(\n        year = vctrs::list_of(.ptype = integer(0)) |>\n          structure(class = c(\"arrow_list\", \"vctrs_list_of\", \"vctrs_vctr\", \"list\")),\n        records = vctrs::list_of(\n          .ptype = tibble::tibble(\n            category = character(0),\n            values = vctrs::list_of(.ptype = numeric(0)) |>\n              structure(class = c(\"arrow_list\", \"vctrs_list_of\", \"vctrs_vctr\", \"list\")),\n          )\n        ) |>\n          structure(class = c(\"arrow_list\", \"vctrs_list_of\", \"vctrs_vctr\", \"list\")),\n      )\n    ) |>\n      structure(class = c(\"arrow_list\", \"vctrs_list_of\", \"vctrs_vctr\", \"list\")),\n  )\n\nmy_tib\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 1\n     my_data\n  <arrw_lst>\n1    [1 × 2]\n```\n\n\n:::\n:::\n\n\n\n# Filter values according to years\n\nI need to filter values according to selected years, without modifying the initial format of the tibble. \nThanks to [@moodymudskipper](https://github.com/moodymudskipper)'s help, I found a way of solving this problem. \n\nSo I am writing this blog post to keep this solution safe.\n\nAs the years are not side by side with the values, we cannot simply use the `filter()` function from the dplyr package. Instead, we need to go into the nested tibble and filter values according to the selected years.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_tib$my_data\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<arrow_list[1]>\n[[1]]\n# A tibble: 1 × 2\n        year    records\n  <arrw_lst> <arrw_lst>\n1        [5]    [7 × 2]\n```\n\n\n:::\n:::\n\n\n\nLet's say we want only the years 2018 and 2021. You need to use the functions `map()` and `map2_dfr()` from the purrr package in order to filter the list elements according to the vector `my_years`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_years <- c(2018L, 2021L)\nmy_tib$my_data <-\n  purrr::map(my_tib$my_data, ~ {\n    # we're in a nested tibble\n    # now iterating on observations of the cols of the nested tibble\n    purrr::map2_dfr(.x$year, .x$records, function(year, record) {\n      record$values <- purrr::map(record$values, \\(x) x[year %in% my_years])\n\n      tibble::tibble(\n        year = vctrs::list_of(year[year %in% my_years]),\n        records = vctrs::list_of(record)\n      )\n    })\n  })\n\nconstructive::construct(my_tib)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ntibble::tibble(\n  my_data = list(\n    tibble::tibble(\n      year = vctrs::list_of(c(2018L, 2021L), .ptype = integer(0)),\n      records = vctrs::list_of(\n        tibble::tibble(\n          category = c(\"categ1\", \"categ2\", \"categ3\", \"categ4\", \"categ5\", \"categ6\", \"categ7\"),\n          values = list(\n            c(100, 130), c(200, 230), c(300, 330), c(400, 430), c(500, 530), c(600, 630),\n            c(700, 730)\n          ),\n        ),\n        .ptype = tibble::tibble(category = character(0), values = list())\n      ),\n    )\n  ),\n)\n```\n\n\n:::\n:::\n\n\nWe end up with the same structure as the initial tibble. Our mission is fulfilled!\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}