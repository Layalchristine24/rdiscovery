{
  "hash": "1e9ef176e68c7bda73b03ea55b839dd0",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: How to replace some non-available values in a vector with values coming from another vector?\nauthor:\n  - name:\n      given: Layal Christine\n      family: Lettry\n      orcid: 0009-0008-6396-0523\n    affiliations:\n      - id: cynkra\n      - name: cynkra GmbH\n        city: Zurich\n        state: CH\n      - id: unifr\n      - name: University of Fribourg, Dept. of Informatics, ASAM Group\n        city: Fribourg\n        state: CH\ndate: 2024-05-10\ncategories: [dplyr, coalesce, if_else, is.na]\nimage: image.jpg\ncitation: \n  url: https://rdiscovery.netlify.app/posts/2024-05-10_coalesce/\nformat:\n  html:\n    toc: true\n    toc-depth: 6\n    toc-title: Contents\n    toc-location: right\n    number-sections: false\neditor_options: \n  chunk_output_type: console\n---\n\n\n*How to replace some non-available values in a vector with values coming from another vector?*\n\nUntil recently, I used to write the following code to fix `NA` values.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_tib <- tibble::tribble(\n  ~var_with_na, ~var_non_na,\n  NA_real_, 1.4,\n  5.4, 5.0,\n  NA_real_, 9.4,\n  13.4, 13.0,\n  NA_real_, 17.4\n)\n\nmy_tib |>\n  dplyr::mutate(\n    my_fixed_var = dplyr::if_else(\n      is.na(var_with_na), var_non_na, var_with_na\n    )\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 3\n  var_with_na var_non_na my_fixed_var\n        <dbl>      <dbl>        <dbl>\n1        NA          1.4          1.4\n2         5.4        5            5.4\n3        NA          9.4          9.4\n4        13.4       13           13.4\n5        NA         17.4         17.4\n```\n\n\n:::\n:::\n\n\nA more efficient way to do this is to use the function [`coalesce()`](https://dplyr.tidyverse.org/reference/coalesce.html) from the dplyr package. This will allow you to **find the first non-missing element in a set of vectors**.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_tib |>\n  dplyr::mutate(\n    my_fixed_var = dplyr::coalesce(var_with_na, var_non_na)\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 3\n  var_with_na var_non_na my_fixed_var\n        <dbl>      <dbl>        <dbl>\n1        NA          1.4          1.4\n2         5.4        5            5.4\n3        NA          9.4          9.4\n4        13.4       13           13.4\n5        NA         17.4         17.4\n```\n\n\n:::\n:::\n\n\nThis function takes all the available values from the vector you set in the first argument and replaces its non-available values with the first non-missing values from the vector in the second argument.\n\nYou could also do this with more than two vectors.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_tib_2 <- tibble::tribble(\n  ~var_with_na_1, ~var_with_na_2, ~var_with_na_3,\n  NA_real_, 1.2, 1.4,\n  5.4, 5.2, NA_real_,\n  NA_real_, NA_real_, NA_real_,\n  13.4, NA_real_, 13.0,\n  NA_real_, NA_real_, 17.4\n)\n\nmy_tib_2 |>\n  dplyr::mutate(\n    my_fixed_var =\n      dplyr::coalesce(var_with_na_1, var_with_na_2, var_with_na_3)\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 4\n  var_with_na_1 var_with_na_2 var_with_na_3 my_fixed_var\n          <dbl>         <dbl>         <dbl>        <dbl>\n1          NA             1.2           1.4          1.2\n2           5.4           5.2          NA            5.4\n3          NA            NA            NA           NA  \n4          13.4          NA            13           13.4\n5          NA            NA            17.4         17.4\n```\n\n\n:::\n:::\n\n\nThe sequence of the vectors specified as arguments in the `coalesce` function determines the order in which the `NA` values of the initial vectors will be replaced with the values of the remaining ones. Remember that **the first non-missing element in a set of vectors** will be taken as a replacement value for the `NA` values in the first vectors. If all values are not available, then the result will also be.\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}