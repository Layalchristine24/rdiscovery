{
  "hash": "a2542bcbf9019532259c128756e388cc",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Analyse vector sequences\nauthor:\n  - name:\n      given: Layal Christine\n      family: Lettry\n      orcid: 0009-0008-6396-0523\n    affiliations:\n      - id: cynkra\n      - name: cynkra GmbH\n        city: Zurich\n        state: CH\n      - id: unifr\n      - name: University of Fribourg, Dept. of Informatics, ASAM Group\n        city: Fribourg\n        state: CH\ndate: 2024-03-28\ncategories: [rle]\nimage: image.jpg\ncitation: \n  url: https://rdiscovery.netlify.app/posts/2024-03-28_rle/\nformat:\n  html:\n    toc: true\n    toc-depth: 6\n    toc-title: Contents\n    toc-location: right\n    number-sections: false\neditor_options: \n  chunk_output_type: console\n---\n\n\n*How can you easily analyse vector sequences in base R?*\n\n# Run-length encoding\n\nFlying over the [GitHub repository about useful and powerful shortcuts in base R](\"https://github.com/nanxstats/r-base-shortcuts#run-length-encoding\"), I stumbled upon an easy way to split a vector into sequences of equal values.\n\nThe function `rle()` allows you to deconstruct a vector. This function shows the frequency of an instance in a certain sequence. If a value is followed by the same one, the `rle()` function will count the number of these successive instances. \n\nThe `rle()` function returns a list of the values and their respective lengths in a vector sequence. The class of this list is `\"rle\"`. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(1L, 5L, 7L, 2L, 2L, 7L, 7L, 7L, 8L, 1L)\n(y <- rle(x))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRun Length Encoding\n  lengths: int [1:7] 1 1 1 2 3 1 1\n  values : int [1:7] 1 5 7 2 7 8 1\n```\n\n\n:::\n\n```{.r .cell-code}\ntidyr::tibble(\n  length_x = y[[\"lengths\"]], values_x = y[[\"values\"]]\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 7 × 2\n  length_x values_x\n     <int>    <int>\n1        1        1\n2        1        5\n3        1        7\n4        2        2\n5        3        7\n6        1        8\n7        1        1\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"list\"\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"rle\"\n```\n\n\n:::\n\n```{.r .cell-code}\nw <- c(2.0, 3.0, 8.0, 8.0, 5.0, 5.0, 5.0, 7.0, 9.0, 9.0)\n(z <- rle(w))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRun Length Encoding\n  lengths: int [1:6] 1 1 2 3 1 2\n  values : num [1:6] 2 3 8 5 7 9\n```\n\n\n:::\n\n```{.r .cell-code}\ntidyr::tibble(\n  length_w = z[[\"lengths\"]], values_w = z[[\"values\"]]\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 2\n  length_w values_w\n     <int>    <dbl>\n1        1        2\n2        1        3\n3        2        8\n4        3        5\n5        1        7\n6        2        9\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(z)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"list\"\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(z)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"rle\"\n```\n\n\n:::\n\n```{.r .cell-code}\nm <- c(FALSE, FALSE, FALSE, TRUE, TRUE, FALSE, FALSE, TRUE)\n(n <- rle(m))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRun Length Encoding\n  lengths: int [1:4] 3 2 2 1\n  values : logi [1:4] FALSE TRUE FALSE TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\ntidyr::tibble(\n  length_m = n[[\"lengths\"]], values_m = n[[\"values\"]]\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 2\n  length_m values_m\n     <int> <lgl>   \n1        3 FALSE   \n2        2 TRUE    \n3        2 FALSE   \n4        1 TRUE    \n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"list\"\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"rle\"\n```\n\n\n:::\n:::\n\n\n# Reverse operation\n\nYou can get the vector back with `inverse.rle()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(inv_y <- inverse.rle(y))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 1 5 7 2 2 7 7 7 8 1\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(inv_y)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"integer\"\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(inv_y)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"integer\"\n```\n\n\n:::\n\n```{.r .cell-code}\n(inv_z <- inverse.rle(z))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 2 3 8 8 5 5 5 7 9 9\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(inv_z)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"double\"\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(inv_z)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"numeric\"\n```\n\n\n:::\n\n```{.r .cell-code}\n(inv_n <- inverse.rle(n))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE FALSE FALSE  TRUE  TRUE FALSE FALSE  TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(inv_n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"logical\"\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(inv_n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"logical\"\n```\n\n\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}