{
  "hash": "f162d792faac54d038eb8c5e1fc5dc91",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: What are the use cases of using nested versus packed data?\nauthor:\n  - name:\n      given: Layal Christine\n      family: Lettry\n      orcid: 0009-0008-6396-0523\n    affiliations:\n      - id: cynkra\n      - name: cynkra GmbH\n        city: Zurich\n        state: CH\n      - id: unifr\n      - name: University of Fribourg, Dept. of Informatics, ASAM Group\n        city: Fribourg\n        state: CH\ndate: 2024-05-30\ncategories: [nest, unnest, pack, unpack, tidyr, json, constructive]\nimage: image.jpg\ncitation: \n  url: https://rdiscovery.netlify.app/posts/2024-06-01_use-case-pack-nest/\nformat:\n  html:\n    toc: true\n    toc-depth: 6\n    toc-title: Contents\n    toc-location: right\n    number-sections: false\neditor_options: \n  chunk_output_type: console\n---\n\n\n*When would you use nested instead packed data (and vice versa)?*\n\nIn my last [blog post](https://rdiscovery.netlify.app/posts/2024-05-30_pack-nest/), we saw how nested data was different from packed data.\n\nIn this article, I would like to explain when we can use nested and packed data.\n\n# Nested data\n\nIn the following example, we will nest data from the tibble `palmerpenguins::penguins` to the raw data `palmerpenguins::penguins_raw`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_nested_tib <-\n  palmerpenguins::penguins |>\n  dplyr::distinct(island) |>\n  dplyr::rename(my_island = island) |>\n  dplyr::mutate(\n    penguins_data = purrr::map(\n      my_island, \\(x) dplyr::filter(palmerpenguins::penguins, island == x)\n    ),\n    penguins_raw_data = purrr::map(\n      my_island, \\(x) dplyr::filter(palmerpenguins::penguins_raw, Island == x)\n    )\n  ) |>\n  dplyr::select(-my_island)\n\ndplyr::glimpse(my_nested_tib)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 3\nColumns: 2\n$ penguins_data     <list> [<tbl_df[52 x 8]>], [<tbl_df[168 x 8]>], [<tbl_df[1…\n$ penguins_raw_data <list> [<tbl_df[52 x 17]>], [<tbl_df[168 x 17]>], [<tbl_df…\n```\n\n\n:::\n:::\n\n\nThe tibble `my_nested_tib` is a nested tibble containing the variables `penguins_data` and `penguins_raw_data`, which are both lists with 3 tibble elements of different dimensions.\nWe can handle these variables like any normal list.\n\nTo unlist our data, we will unnest the columns `penguins_data` and `penguins_raw_data`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_unnested_tib <-\n  my_nested_tib |>\n  tidyr::unnest(\n    cols = c(penguins_data, penguins_raw_data)\n  )\ndplyr::glimpse(my_unnested_tib)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 344\nColumns: 25\n$ species               <fct> Adelie, Adelie, Adelie, Adelie, Adelie, Adelie, …\n$ island                <fct> Torgersen, Torgersen, Torgersen, Torgersen, Torg…\n$ bill_length_mm        <dbl> 39.1, 39.5, 40.3, NA, 36.7, 39.3, 38.9, 39.2, 34…\n$ bill_depth_mm         <dbl> 18.7, 17.4, 18.0, NA, 19.3, 20.6, 17.8, 19.6, 18…\n$ flipper_length_mm     <int> 181, 186, 195, NA, 193, 190, 181, 195, 193, 190,…\n$ body_mass_g           <int> 3750, 3800, 3250, NA, 3450, 3650, 3625, 4675, 34…\n$ sex                   <fct> male, female, female, NA, female, male, female, …\n$ year                  <int> 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007, …\n$ studyName             <chr> \"PAL0708\", \"PAL0708\", \"PAL0708\", \"PAL0708\", \"PAL…\n$ `Sample Number`       <dbl> 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 1…\n$ Species               <chr> \"Adelie Penguin (Pygoscelis adeliae)\", \"Adelie P…\n$ Region                <chr> \"Anvers\", \"Anvers\", \"Anvers\", \"Anvers\", \"Anvers\"…\n$ Island                <chr> \"Torgersen\", \"Torgersen\", \"Torgersen\", \"Torgerse…\n$ Stage                 <chr> \"Adult, 1 Egg Stage\", \"Adult, 1 Egg Stage\", \"Adu…\n$ `Individual ID`       <chr> \"N1A1\", \"N1A2\", \"N2A1\", \"N2A2\", \"N3A1\", \"N3A2\", …\n$ `Clutch Completion`   <chr> \"Yes\", \"Yes\", \"Yes\", \"Yes\", \"Yes\", \"Yes\", \"No\", …\n$ `Date Egg`            <date> 2007-11-11, 2007-11-11, 2007-11-16, 2007-11-16,…\n$ `Culmen Length (mm)`  <dbl> 39.1, 39.5, 40.3, NA, 36.7, 39.3, 38.9, 39.2, 34…\n$ `Culmen Depth (mm)`   <dbl> 18.7, 17.4, 18.0, NA, 19.3, 20.6, 17.8, 19.6, 18…\n$ `Flipper Length (mm)` <dbl> 181, 186, 195, NA, 193, 190, 181, 195, 193, 190,…\n$ `Body Mass (g)`       <dbl> 3750, 3800, 3250, NA, 3450, 3650, 3625, 4675, 34…\n$ Sex                   <chr> \"MALE\", \"FEMALE\", \"FEMALE\", NA, \"FEMALE\", \"MALE\"…\n$ `Delta 15 N (o/oo)`   <dbl> NA, 8.94956, 8.36821, NA, 8.76651, 8.66496, 9.18…\n$ `Delta 13 C (o/oo)`   <dbl> NA, -24.69454, -25.33302, NA, -25.32426, -25.298…\n$ Comments              <chr> \"Not enough blood for isotopes.\", NA, NA, \"Adult…\n```\n\n\n:::\n:::\n\n\n\n# Packed data\n\nYou would need to pack data into groups so that you can easily compare them. \nOpposite to `my_unnested_tib`, our tibble `my_packed_data` will be narrow because similar columns will be consolidated into a single variable. \nYou will find additional information about the packing process in this [article](https://tidyr.tidyverse.org/reference/pack.html).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_packed_data <-\n  my_unnested_tib |>\n  tidyr::pack(\n    all_species = c(species, Species),\n    all_island = c(island, Island),\n    all_bill_length_mm = c(bill_length_mm, `Culmen Length (mm)`),\n    all_bill_depth_mm = c(bill_depth_mm, `Culmen Depth (mm)`),\n    all_flipper_length_mm = c(flipper_length_mm, `Flipper Length (mm)`),\n    all_body_mass_g = c(body_mass_g, `Body Mass (g)`),\n    all_sex = c(sex, Sex),\n    all_date = c(year, `Date Egg`),\n    all_remaining_raw_data = c(\n      studyName, `Sample Number`, Region, Stage, `Individual ID`,\n      `Clutch Completion`, `Delta 15 N (o/oo)`, `Delta 13 C (o/oo)`,\n      Comments\n    )\n  )\ndplyr::glimpse(my_packed_data)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 344\nColumns: 9\n$ all_species            <tibble[,2]> <tbl_df[26 x 2]>\n$ all_island             <tibble[,2]> <tbl_df[26 x 2]>\n$ all_bill_length_mm     <tibble[,2]> <tbl_df[26 x 2]>\n$ all_bill_depth_mm      <tibble[,2]> <tbl_df[26 x 2]>\n$ all_flipper_length_mm  <tibble[,2]> <tbl_df[26 x 2]>\n$ all_body_mass_g        <tibble[,2]> <tbl_df[26 x 2]>\n$ all_sex                <tibble[,2]> <tbl_df[26 x 2]>\n$ all_date               <tibble[,2]> <tbl_df[26 x 2]>\n$ all_remaining_raw_data <tibble[,9]> <tbl_df[26 x 9]>\n```\n\n\n:::\n:::\n\n\nNow, `my_packed_data` is a tibble with 9 columns instead of 25 for `my_unnested_tib`.\n\nYou can either subset it using the dollar sign `$` or square brackets `[[]]`.\nFor example, you could write `my_packed_data$all_body_mass_g$body_mass_g`, `my_packed_data$all_body_mass_g[[\"body_mass_g\"]]` or `my_packed_data[[\"all_body_mass_g\"]][[\"body_mass_g\"]]`.\nThis will give you the same result.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwaldo::compare(\n  my_packed_data$all_body_mass_g$body_mass_g,\n  my_packed_data$all_body_mass_g[[\"body_mass_g\"]]\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n✔ No differences\n```\n\n\n:::\n\n```{.r .cell-code}\nwaldo::compare(\n  my_packed_data$all_body_mass_g$body_mass_g,\n  my_packed_data[[\"all_body_mass_g\"]][[\"body_mass_g\"]]\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n✔ No differences\n```\n\n\n:::\n:::\n\n\nFurthermore, it is so organised that you can easily analyse the differences between `palmerpenguins::penguins` and `palmerpenguins::penguins_raw`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Species from penguins_raw and species from penguins (old vs new)\nwaldo::compare(\n  my_packed_data$all_species$Species,\n  my_packed_data$all_species$species\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n`old` is a character vector ('Adelie Penguin (Pygoscelis adeliae)', 'Adelie Penguin (Pygoscelis adeliae)', 'Adelie Penguin (Pygoscelis adeliae)', 'Adelie Penguin (Pygoscelis adeliae)', 'Adelie Penguin (Pygoscelis adeliae)', ...)\n`new` is an S3 object of class <factor>, an integer vector\n```\n\n\n:::\n\n```{.r .cell-code}\n# Island from penguins_raw and island from penguins (old vs new)\nwaldo::compare(\n  my_packed_data$all_island$Island,\n  my_packed_data$all_island$island\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n`old` is a character vector ('Torgersen', 'Torgersen', 'Torgersen', 'Torgersen', 'Torgersen', ...)\n`new` is an S3 object of class <factor>, an integer vector\n```\n\n\n:::\n\n```{.r .cell-code}\n# `Culmen Length (mm)` from penguins_raw and bill_length_mm from penguins (old vs new)\nwaldo::compare(\n  my_packed_data$all_bill_length_mm$`Culmen Length (mm)`,\n  my_packed_data$all_bill_length_mm$bill_length_mm\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n✔ No differences\n```\n\n\n:::\n:::\n\n\nYou can also easily obtain the columns `palmerpenguins::penguins_raw` that were not included in `palmerpenguins::penguins` and unpack them.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_raw_additional_columns <-\n  my_packed_data |>\n  dplyr::select(all_remaining_raw_data) |>\n  tidyr::unpack(all_remaining_raw_data)\n\ndplyr::glimpse(my_raw_additional_columns)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 344\nColumns: 9\n$ studyName           <chr> \"PAL0708\", \"PAL0708\", \"PAL0708\", \"PAL0708\", \"PAL07…\n$ `Sample Number`     <dbl> 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,…\n$ Region              <chr> \"Anvers\", \"Anvers\", \"Anvers\", \"Anvers\", \"Anvers\", …\n$ Stage               <chr> \"Adult, 1 Egg Stage\", \"Adult, 1 Egg Stage\", \"Adult…\n$ `Individual ID`     <chr> \"N1A1\", \"N1A2\", \"N2A1\", \"N2A2\", \"N3A1\", \"N3A2\", \"N…\n$ `Clutch Completion` <chr> \"Yes\", \"Yes\", \"Yes\", \"Yes\", \"Yes\", \"Yes\", \"No\", \"N…\n$ `Delta 15 N (o/oo)` <dbl> NA, 8.94956, 8.36821, NA, 8.76651, 8.66496, 9.1871…\n$ `Delta 13 C (o/oo)` <dbl> NA, -24.69454, -25.33302, NA, -25.32426, -25.29805…\n$ Comments            <chr> \"Not enough blood for isotopes.\", NA, NA, \"Adult n…\n```\n\n\n:::\n:::\n\n\n# When should you use nested data or packed data when using a JSON format?\n\nIn my experience, I used nested and packed data in an API so that you could read it in JSON format at the end.\n\nIn my opinion, it is preferable to use nested data when you have a tibble of several rows. \nOn the contrary, when a single row is involved, it is recommended to use packed data to avoid square brackets.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmultiple_rows_tib <-\n  tibble::tribble(\n    ~category, ~value,\n    \"category1\", seq(from = 1.092, to = 1.098, by = 0.001),\n    \"category2\", seq(from = 352.15, to = 352.2, by = 0.01),\n    \"category3\", seq(from = 25.63, to = 25.7, by = 0.01)\n  )\n\nmy_date <- \"2022-09-12\"\nsingle_row_tib <-\n  tibble::tribble(\n    ~year, ~month, ~day,\n    lubridate::year(my_date), lubridate::month(my_date, label = TRUE), lubridate::day(my_date)\n  )\n\nmy_tib <-\n  tibble::tibble(\n    all_values = vctrs::list_of(multiple_rows_tib),\n    date = tidyr::pack(single_row_tib)\n  )\n\njsonlite::toJSON(my_tib, pretty = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[\n  {\n    \"all_values\": [\n      {\n        \"category\": \"category1\",\n        \"value\": [1.092, 1.093, 1.094, 1.095, 1.096, 1.097, 1.098]\n      },\n      {\n        \"category\": \"category2\",\n        \"value\": [352.15, 352.16, 352.17, 352.18, 352.19, 352.2]\n      },\n      {\n        \"category\": \"category3\",\n        \"value\": [25.63, 25.64, 25.65, 25.66, 25.67, 25.68, 25.69, 25.7]\n      }\n    ],\n    \"date\": {\n      \"year\": 2022,\n      \"month\": \"Sep\",\n      \"day\": 12\n    }\n  }\n] \n```\n\n\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}